using System.Linq;
using System.Text;
using Content.Client._NF.Lathe.UI; // Frontier
using Content.Client.Materials;
using Content.Client.UserInterface.Controls;
using Content.Shared.Lathe;
using Content.Shared.Lathe.Prototypes;
using Content.Shared.Materials;
using Content.Shared.Research.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;

namespace Content.Client.Lathe.UI;

[GenerateTypedNameReferences]
public sealed partial class LatheMenu : DefaultWindow
{
    [Dependency] private readonly IEntityManager _entityManager = default!;
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;

    private readonly SpriteSystem _spriteSystem;
    private readonly LatheSystem _lathe;
    private readonly MaterialStorageSystem _materialStorage;

    public event Action<BaseButton.ButtonEventArgs>? OnServerListButtonPressed;
    public event Action<string, int>? RecipeQueueAction;
    public event Action<int>? QueueDeleteAction; // Frontier
    public event Action<int>? QueueMoveUpAction; // Frontier
    public event Action<int>? QueueMoveDownAction; // Frontier
    public event Action? DeleteFabricatingAction; // Frontier

    public List<ProtoId<LatheRecipePrototype>> Recipes = new();

    public List<ProtoId<LatheCategoryPrototype>>? Categories;

    public ProtoId<LatheCategoryPrototype>? CurrentCategory;

    public EntityUid Entity;

    public LatheMenu()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _spriteSystem = _entityManager.System<SpriteSystem>();
        _lathe = _entityManager.System<LatheSystem>();
        _materialStorage = _entityManager.System<MaterialStorageSystem>();

        SearchBar.OnTextChanged += _ =>
        {
            PopulateRecipes();
        };
        AmountLineEdit.OnTextChanged += _ =>
        {
            PopulateRecipes();
        };
        UseMaxButton.OnToggled += _ =>
        {
            HandleMaxToggled();
        };
        FilterOption.OnItemSelected += OnItemSelected;

        ServerListButton.OnPressed += a => OnServerListButtonPressed?.Invoke(a);
        DeleteFabricating.OnPressed += _ => DeleteFabricatingAction?.Invoke(); // Frontier
        DeleteFabricating.AddStyleClass("OpenLeft"); // Frontier
    }

    public void SetEntity(EntityUid uid)
    {
        Entity = uid;

        if (_entityManager.TryGetComponent<LatheComponent>(Entity, out var latheComponent))
        {
            if (!latheComponent.DynamicPacks.Any())
            {
                ServerListButton.Visible = false;
            }

            AmountLineEdit.SetText(latheComponent.DefaultProductionAmount.ToString());
        }

        MaterialsList.SetOwner(Entity);
    }

    private int CalculateMaximumofRecipe(LatheRecipePrototype recipe, MaterialStorageSystem materialStorage)
    {
        List<int> craftableAmounts = new List<int>();
        foreach (var (id, amount) in recipe.Materials)
        {
            craftableAmounts.Add(materialStorage.GetMaterialAmount(Entity, id)/amount);
        }
        return craftableAmounts.Count > 0 ? craftableAmounts.Min() : 0;
    }
    /// <summary>
    /// Populates the list of all the recipes
    /// </summary>
    public void PopulateRecipes()
    {
        // build the recipes to show
        var recipesToShow = new List<LatheRecipePrototype>();
        foreach (var recipe in Recipes)
        { //for each recipe in the prototype (YAML) filter through them by checking to see if they exist (TryIndex)
            //or skip them
            if (!_prototypeManager.TryIndex(recipe, out var proto))
                continue;

            // Category filtering
            // If the category is specified
            if (CurrentCategory != null)
            {//if there isnt' any category in the prototype dont bother
                if (proto.Categories.Count <= 0)
                    continue;
                // check to see if the recipe is valid for the category specified
                var validRecipe = proto.Categories.Any(category => category == CurrentCategory);
                // if its not skip it
                if (!validRecipe)
                    continue;
            }
            // if the search bar has something in it check and make sure the filtered recipes by category are further filtered here
            if (SearchBar.Text.Trim().Length != 0)
            {
                if (_lathe.GetRecipeName(recipe).ToLowerInvariant().Contains(SearchBar.Text.Trim().ToLowerInvariant()))
                    recipesToShow.Add(proto);
            }
            else
            {   //add the recipe from the prototype (YAML)
                recipesToShow.Add(proto);
            }
        }

        //does this even matter? oh yeah it matters nvm
        if (!int.TryParse(AmountLineEdit.Text, out var quantity) || quantity <= 0)
            quantity = 1;
        //build the string using the locale system (handles string translations in a one stop shop way)
        //the string is built with the number of recipes shown and then translated based on user settings (e.g. EN uses english strings)
        RecipeCount.Text = Loc.GetString("lathe-menu-recipe-count", ("count", recipesToShow.Count));

        //sort the recipes so they look consistent every time
        var sortedRecipesToShow = recipesToShow.OrderBy(_lathe.GetRecipeName);
        //clear the old list
        RecipeList.Children.Clear();
        //try to yoink the lathe component from the current entity - entities are made up of components, and a lathe entity should have a component that's a lathe component
        _entityManager.TryGetComponent(Entity, out LatheComponent? lathe);

        //for each "thing" we call a prototype in sortedRecipesToShow
        // in reality, each prototype is the recipe to show that's been filtered.
        // it's called a prototype bsecause the game inists to use YAML files and
        // they are read into a "recipe prototype" class
        foreach (var prototype in sortedRecipesToShow)
        {
            //check if this lathe can produce the current recipe
            var canProduce = _lathe.CanProduce(Entity, prototype, quantity, component: lathe);
            //make a new recipe button for this item - if it can be produced, we'll allow at least 1 to be made
            //the amountlineedit.text being set to 1 just makes it so by default 1 is crated
            var control = new RecipeControl(_lathe, prototype, () => GenerateTooltipText(prototype), canProduce, GetRecipeDisplayControl(prototype));
            control.OnButtonPressed += s =>
            {
                //here if the amount is zero (0) one will be crafted anyway when you click the button
                //kinda dumb imo but I bet people forget they set it to zero

                // if UseMaxButton is pressed, - my code
                int amount;
                if (UseMaxButton.Pressed)
                {
                    amount = CalculateMaximumofRecipe(prototype, _materialStorage);
                }
                else if (!int.TryParse(AmountLineEdit.Text, out amount) || amount <= 0)
                {

                    amount = 1;
                    //this tells the button to queue up the recipe to the server by invoking an action
                    // s = the recipe being made, amount = how much we're making
                }
                RecipeQueueAction?.Invoke(s, amount);
            };
            //add the buttons we made in the for each loop to the client
            RecipeList.AddChild(control);
        }
    }

    private string GenerateTooltipText(LatheRecipePrototype prototype)
    {
        StringBuilder sb = new();
        var multiplier = _entityManager.GetComponent<LatheComponent>(Entity).FinalMaterialUseMultiplier; // Frontier: MaterialUseMultiplier<FinalMaterialUseMultiplier

        foreach (var (id, amount) in prototype.Materials)
        {
            if (!_prototypeManager.TryIndex(id, out var proto))
                continue;

            var adjustedAmount = SharedLatheSystem.AdjustMaterial(amount, prototype.ApplyMaterialDiscount, multiplier);
            var sheetVolume = _materialStorage.GetSheetVolume(proto);

            var unit = Loc.GetString(proto.Unit);
            var sheets = adjustedAmount / (float) sheetVolume;

            var availableAmount = _materialStorage.GetMaterialAmount(Entity, id);
            var missingAmount = Math.Max(0, adjustedAmount - availableAmount);
            var missingSheets = missingAmount / (float) sheetVolume;

            var name = Loc.GetString(proto.Name);

            string tooltipText;
            if (missingSheets > 0)
            {
                tooltipText = Loc.GetString("lathe-menu-material-amount-missing", ("amount", sheets), ("missingAmount", missingSheets), ("unit", unit), ("material", name));
            }
            else
            {
                var amountText = Loc.GetString("lathe-menu-material-amount", ("amount", sheets), ("unit", unit));
                tooltipText = Loc.GetString("lathe-menu-tooltip-display", ("material", name), ("amount", amountText));
            }

            sb.AppendLine(tooltipText);
        }

        var desc = _lathe.GetRecipeDescription(prototype);
        if (!string.IsNullOrWhiteSpace(desc))
            sb.AppendLine(Loc.GetString("lathe-menu-description-display", ("description", desc)));

        // Remove last newline
        if (sb.Length > 0)
            sb.Remove(sb.Length - 1, 1);

        return sb.ToString();
    }

    public void UpdateCategories()
    {
        // Get categories from recipes
        var currentCategories = new List<ProtoId<LatheCategoryPrototype>>();
        foreach (var recipeId in Recipes)
        {
            var recipe = _prototypeManager.Index(recipeId);

            if (recipe.Categories.Count <= 0)
                continue;

            foreach (var category in recipe.Categories)
            {
                if (currentCategories.Contains(category))
                    continue;

                currentCategories.Add(category);
            }
        }

        if (Categories != null && (Categories.Count == currentCategories.Count || !Categories.All(currentCategories.Contains)))
            return;

        Categories = currentCategories;
        var sortedCategories = currentCategories
            .Select(p => _prototypeManager.Index(p))
            .OrderBy(p => Loc.GetString(p.Name))
            .ToList();

        FilterOption.Clear();
        FilterOption.AddItem(Loc.GetString("lathe-menu-category-all"), -1);
        foreach (var category in sortedCategories)
        {
            FilterOption.AddItem(Loc.GetString(category.Name), Categories.IndexOf(category.ID));
        }

        FilterOption.SelectId(-1);
    }

    private void HandleMaxToggled()
    {
        if (UseMaxButton.Pressed)
        {
            AmountLineEdit.Editable =  false;
            AmountLineEdit.Text = "Disabled"; //1 item is still made when this is set t
        }
        else
        {
            AmountLineEdit.Editable = true;
            AmountLineEdit.Text = "10";
        }
    }
    /// <summary>
    /// Populates the build queue list with all queued items
    /// </summary>
    /// <param name="queue"></param>
    public void PopulateQueueList(List<LatheRecipeBatch> queue) // Frontier: IReadOnlyCollection<ProtoId<LatheRecipePrototype>> < List<LatheRecipeBatch>
    {
        QueueList.DisposeAllChildren();

        var idx = 1;
        foreach (var batch in queue) // Frontier: recipe<batch
        {
            // Frontier: custom boxes
            // var recipe = _prototypeManager.Index(recipeProto);
            // var queuedRecipeBox = new BoxContainer();
            // queuedRecipeBox.Orientation = BoxContainer.LayoutOrientation.Horizontal;

            // // Frontier: batch handling
            // queuedRecipeBox.AddChild(GetRecipeDisplayControl(batch.Recipe)); // Frontier: GetRecipeDisplayControl<GetQueueRecipeDisplayControl

            // var queuedRecipeLabel = new Label();
            // if (batch.ItemsRequested > 1)
            //     queuedRecipeLabel.Text = $"{idx}. {_lathe.GetRecipeName(batch.Recipe)} ({batch.ItemsPrinted}/{batch.ItemsRequested})";
            // else
            //     queuedRecipeLabel.Text = $"{idx}. {_lathe.GetRecipeName(batch.Recipe)}";
            // // End Frontier
            // queuedRecipeBox.AddChild(queuedRecipeLabel);
            // QueueList.AddChild(queuedRecipeBox);

            string displayText;
            if (batch.ItemsRequested > 1)
                displayText = $"{idx}. {_lathe.GetRecipeName(batch.Recipe)} ({batch.ItemsPrinted}/{batch.ItemsRequested})";
            else
                displayText = $"{idx}. {_lathe.GetRecipeName(batch.Recipe)}";
            var queuedRecipeBox = new QueuedRecipeControl(displayText, idx - 1, GetRecipeDisplayControl(_prototypeManager.Index(batch.Recipe)));
            queuedRecipeBox.OnDeletePressed += s => QueueDeleteAction?.Invoke(s);
            queuedRecipeBox.OnMoveUpPressed += s => QueueMoveUpAction?.Invoke(s);
            queuedRecipeBox.OnMoveDownPressed += s => QueueMoveDownAction?.Invoke(s);
            QueueList.AddChild(queuedRecipeBox);
            // End Frontier: custom boxes
            idx++;
        }
    }

    public void SetQueueInfo(ProtoId<LatheRecipePrototype>? recipeProto)
    {
        FabricatingContainer.Visible = recipeProto != null;
        if (recipeProto == null)
            return;

        var recipe = _prototypeManager.Index(recipeProto.Value);

        FabricatingDisplayContainer.Children.Clear();
        FabricatingDisplayContainer.AddChild(GetRecipeDisplayControl(recipe));

        NameLabel.Text = _lathe.GetRecipeName(recipe);
    }

    public Control GetRecipeDisplayControl(LatheRecipePrototype recipe)
    {
        if (recipe.Icon != null)
        {
            var textRect = new TextureRect();
            textRect.Texture = _spriteSystem.Frame0(recipe.Icon);
            return textRect;
        }

        if (recipe.Result is { } result)
        {
            var entProtoView = new EntityPrototypeView();
            entProtoView.SetPrototype(result);
            return entProtoView;
        }

        return new Control();
    }

    private void OnItemSelected(OptionButton.ItemSelectedEventArgs obj)
    {
        FilterOption.SelectId(obj.Id);
        if (obj.Id == -1)
        {
            CurrentCategory = null;
        }
        else
        {
            CurrentCategory = Categories?[obj.Id];
        }
        PopulateRecipes();
    }
}
