using Content.Client.UserInterface.Controls;
using Content.Shared._NF.Power;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;

namespace Content.Client._NF.Power.Battery;

/// <summary>
/// Interface control for items with adjustable power draw.
/// </summary>
/// <seealso cref="BatteryBoundUserInterface"/>
[GenerateTypedNameReferences]
public sealed partial class AdjustablePowerDrawMenu : FancyWindow
{
    // Dependencies
    [Dependency] private readonly IEntityManager _entityManager = null!;
    [Dependency] private readonly ILocalizationManager _loc = null!;

    // The entity that this UI is for.
    private EntityUid _entity;

    // Events for the BUI to subscribe to.
    public event Action<float>? OnSetLoad;
    public event Action<bool>? OnSetPower;

    public AdjustablePowerDrawMenu()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        // TODO: Populate power unit dropdown
        PowerDropDown.AddChild();
    }

    public void SetEntity(EntityUid entity)
    {
        _entity = entity;

        this.SetInfoFromEntity(_entityManager, _entity);
    }

    public void Update(AdjustablePowerDrawBuiState msg)
    {
        TogglePowerButton.Pressed = msg.On;

        // Get logarithm of power
        if (msg.Load >= 0)
        {

        }
    }

    private void SetPowerLineState(PanelContainer control, bool value)
    {
        control.PanelOverride = value ? _activePowerLineStyleBox : _inactivePowerLineStyleBox;
    }

    private string FormatPower(float value)
    {
        return _loc.GetString("battery-menu-power-value", ("value", value));
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        // Pulse power lines.
        _powerPulseValue += args.DeltaSeconds * PowerPulseFactor;

        var color = Color.InterpolateBetween(
            ActivePowerLineLowColor,
            ActivePowerLineHighColor,
            MathF.Sin(_powerPulseValue) / 2 + 1);
        _activePowerLineStyleBox.BackgroundColor = color;

        // Update storage indicator and blink it.
        for (var i = 0; i < _chargeMeterBoxes.Length; i++)
        {
            var box = _chargeMeterBoxes[i];
            if (_storageLevel > i)
            {
                // On
                box.BackgroundColor = StorageColors[i];
            }
            else
            {
                box.BackgroundColor = DimStorageColors[i];
            }
        }

        _blinkPulseValue += args.DeltaSeconds;
        if (_blinkPulseValue > 1)
        {
            _blinkPulseValue -= 1;
            _blinkPulse ^= true;
        }

        // If there is a storage delta (charging or discharging), we want to blink the highest bar.
        if (_hasStorageDelta)
        {
            // If there is no highest bar (UI completely at 0), then blink bar 0.
            var toBlink = Math.Max(0, _storageLevel - 1);
            _chargeMeterBoxes[toBlink].BackgroundColor =
                _blinkPulse ? StorageColors[toBlink] : DimStorageColors[toBlink];
        }
    }
}
