using Content.Shared._Goobstation.Research; // Frontier
using Content.Shared.Research.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility; // Added for SpriteSpecifier

namespace Content.Client._Goobstation.Research.UI;

[GenerateTypedNameReferences]
public sealed partial class FancyResearchConsoleItem : LayoutContainer
{
    // Public fields
    public TechnologyPrototype Prototype;
    public Action<TechnologyPrototype, ResearchAvailability>? SelectAction;
    public ResearchAvailability Availability;

    // Some visuals
    public static readonly Color DefaultColor = Color.FromHex("#141F2F");
    public static readonly Color DefaultBorderColor = Color.FromHex("#4972A1");
    public static readonly Color DefaultHoveredColor = Color.FromHex("#4972A1");

    public Color Color = DefaultColor;
    public Color BorderColor = DefaultBorderColor;
    public Color HoveredColor = DefaultHoveredColor;

    public FancyResearchConsoleItem(TechnologyPrototype proto, SpriteSystem sprite, ResearchAvailability availability)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        Availability = availability;
        Prototype = proto;

        // Handle technology icon - prioritize EntityIcon for full sprite layers
        if (proto.EntityIcon.HasValue)
        {
            // Use EntityPrototypeView to show all sprite layers
            ResearchDisplay.SetPrototype(proto.EntityIcon.Value);
        }
        else if (proto.Icon != null)
        {
            // For legacy Icon support, we need to handle this differently since EntityPrototypeView
            // expects entity prototypes. For now, we'll need a fallback approach.
            // TODO: Consider deprecating the Icon field in favor of EntityIcon

            // We cannot directly set a SpriteSpecifier on EntityPrototypeView
            // This is a limitation of the new approach - EntityIcon should be preferred
            // For now, this will show no icon for legacy Icon-only technologies
            ResearchDisplay.SetPrototype(null);
        }
        else
        {
            // No icon specified
            ResearchDisplay.SetPrototype(null);
        }

        Button.OnPressed += Selected;
        Button.OnDrawModeChanged += UpdateColor;

        (Color, HoveredColor, BorderColor) = availability switch
        {
            ResearchAvailability.Researched => (Color.DarkOliveGreen, Color.PaleGreen, Color.LimeGreen),
            ResearchAvailability.Available => (Color.FromHex("#7c7d2a"), Color.FromHex("#ecfa52"), Color.FromHex("#e8fa25")),
            ResearchAvailability.PrereqsMet => (Color.FromHex("#6b572f"), Color.FromHex("#fad398"), Color.FromHex("#cca031")),
            ResearchAvailability.Unavailable => (Color.DarkRed, Color.PaleVioletRed, Color.Crimson),
            _ => (Color.DarkRed, Color.PaleVioletRed, Color.Crimson)
        };

        // Create rounded style box with 8px corner radius
        var roundedStyle = new RoundedStyleBoxFlat
        {
            BackgroundColor = Color,
            BorderColor = BorderColor,
            BorderThickness = new Thickness(1.5f),
            CornerRadius = 8f
        };

        Panel.PanelOverride = roundedStyle;
        UpdateColor();
    }

    private void UpdateColor()
    {
        if (Panel.PanelOverride is RoundedStyleBoxFlat panel)
        {
            panel.BackgroundColor = Button.IsHovered ? HoveredColor : Color;
            panel.BorderColor = BorderColor;
        }
    }

    protected override void ExitedTree()
    {
        base.ExitedTree();

        Button.OnPressed -= Selected;
    }

    private void Selected(BaseButton.ButtonEventArgs args)
    {
        SelectAction?.Invoke(Prototype, Availability);
    }
}

public sealed class DrawButton : Button
{
    public event Action? OnDrawModeChanged;

    public DrawButton()
    {
    }

    protected override void DrawModeChanged()
    {
        OnDrawModeChanged?.Invoke();
    }
}
