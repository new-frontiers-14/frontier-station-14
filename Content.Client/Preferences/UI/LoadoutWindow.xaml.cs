using Content.Client.Lobby;
using Content.Client.UserInterface.Controls;
using Content.Shared.Preferences.Loadouts;
using Content.Shared.Preferences.Loadouts.Effects;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Player;
using Robust.Shared.Prototypes;

namespace Content.Client.Preferences.UI;

[GenerateTypedNameReferences]
public sealed partial class LoadoutWindow : FancyWindow
{
    public event Action<ProtoId<LoadoutGroupPrototype>, ProtoId<LoadoutPrototype>>? OnLoadoutPressed;
    public event Action<ProtoId<LoadoutGroupPrototype>, ProtoId<LoadoutPrototype>>? OnLoadoutUnpressed;

    private List<LoadoutGroupContainer> _groups = new();

    public LoadoutWindow(RoleLoadout loadout, RoleLoadoutPrototype proto, ICommonSession session, IDependencyCollection collection)
    {
        RobustXamlLoader.Load(this);
        var protoManager = collection.Resolve<IPrototypeManager>();

        foreach (var group in proto.Groups)
        {
            if (!protoManager.TryIndex(group, out var groupProto))
                continue;

            var container = new LoadoutGroupContainer(loadout, protoManager.Index(group), session, collection);

            LoadoutGroupsContainer.AddTab(container, Loc.GetString(groupProto.Name));
            _groups.Add(container);
            container.OnLoadoutPressed += args =>
            {
                OnLoadoutPressed?.Invoke(group, args);
            };

            container.OnLoadoutUnpressed += args =>
            {
                OnLoadoutUnpressed?.Invoke(group, args);
            };
        }
        //Frontier - we inject our label here but it needs recalculating every time a new item is selected,
        //so we add a new method and call it there too.
        CalculateLoadoutCost(loadout, collection);
    }

    public override void Close()
    {
        base.Close();
        var controller = UserInterfaceManager.GetUIController<LobbyUIController>();
        controller.SetDummyJob(null);
    }

    public void RefreshLoadouts(RoleLoadout loadout, ICommonSession session, IDependencyCollection collection)
    {
        foreach (var group in _groups)
        {
            group.RefreshLoadouts(loadout, session, collection);
        }

        CalculateLoadoutCost(loadout, collection); //Frontier
    }

    /// <summary>
    /// Frontier function to calculate and update the label.
    /// </summary>
    /// <param name="loadout">The currently selected loadout</param>
    /// <param name="collection">IDependency Collection of various dependencies</param>
    private void CalculateLoadoutCost(RoleLoadout loadout, IDependencyCollection collection)
    {
        var protoManager = collection.Resolve<IPrototypeManager>();
        var cost = 0;
        foreach (var loadoutGroup in loadout.SelectedLoadouts)
        {
            foreach (var equipment in loadoutGroup.Value)
            {
                if (protoManager.TryIndex(equipment.Prototype, out var equipProto))
                {
                    cost += equipProto.Price;
                }
            }
        }

        Cost.Margin = new Thickness(5, 2, 5, 5);
        Cost.Text = Loc.GetString("frontier-loadout-cost", ("cost", cost));
    }
}
